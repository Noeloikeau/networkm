# AUTOGENERATED! DO NOT EDIT! File to edit: 01_models.ipynb (unless otherwise specified).

__all__ = ['NetworkModel', 'dde_iter', 'dde_iter']

# Cell
import networkx as nx
import numpy as np
import typing
from typing import Optional, Tuple, Dict, Callable, Union, Mapping, Sequence, Iterable, Hashable, List, Any
from collections import namedtuple
import sidis
from sidis import *

# Cell
class NetworkModel(Network):
    '''
    Generic network model class. Has base functionality for incorporating
    a network and simulating its dynamics, as well as executing arbitrary
    routines. Can pass a network `g`, `node_data`, `edge_data`, and `kwargs`
    which get placed as attributes. `routines` is a list of functions,
    args, kwargs, and optional string attributes, which specify a list
    of functions to execute over the args and kwargs, and whether to set
    the result as an attribute of the model. This allows for arbitrary
    executions of routines. Finally, `derivative`, `integrator`, and
    `visualizer` specify the state-change and plotting functions.
    '''
    def __init__(self,
                 g : Union[None,Network,nx.MultiDiGraph] = None,
                 node_data : Dict = {},
                 edge_data : Dict = {},
                 routines : List[Tuple[callable,tuple,dict,str]] = [(None,(),{},None)],
                 derivative : Optional[callable] = None,
                 integrator : Optional[callable] = None,
                 visualizer : Optional[callable] = None,
                 exclusions : List[str] = ['self'],
                 *args,
                 **kwargs
                ):

        self.__dict__.update({k:v for k,v in locals().items() if k not in exclusions})

        super().__init__(g,relabel=True,view='out')

        self.give(node_data=node_data,edge_data=edge_data)

        self.routine(routines)


        def give(self,node_data=None,edge_data=None,model_data=None,nodes=None,edges=None):
            self.give_nodes(data=node_data,nodes=nodes,**node_data)
            self.give_edges(data=edge_data,edges=edges,**edge_data)
            self.give_self(data=model_data,**model_data)
            self.node_data(save=True)
            self.edge_data(save=True)

        def derive(self,*args,**kwargs):
            res = self.derivative(*args,**kwargs)
            if res:
                return res
        @timer
        def integrate(self,*args,**kwargs):
            res = self.integrator(*args,**kwargs)
            if res:
                return res

        def visualize(self,*args,**kwargs):
            res = self.visualizer(*args,**kwargs)
            if res:
                return res

        def routine(self,routines=None):
            if routines is None:
                routines=self.routines
            res = []
            for tup in routines:
                if len(tup)==3: #return func eval
                    f,args,kwargs = tup
                    try:
                        res += [f(*args,**kwargs)]
                    except:
                        pass
                elif len(tup) == 4: #set eval as str
                    f,args,kwargs,attr = tup
                    try:
                        temp=f(*args,**kwargs)
                        setattr(self,attr,temp)
                    except:
                        pass
            if res:
                return res

# Cell
def dde_iter(G : Network,
             delay_key : str = 'delay') -> List[List[Union[tuple,np.ndarray,np.ndarray]]]:
    '''
    Construct a list of iterables used in the calculation
    of a delay-differential-equation (dde) for a network `G`.
    Returns a list-of-lists containing  [(node_start,node_stop),
    adjacency matrix, delay matrix] for each in-degree group.
    '''
    res=[]
    node_index=0
    for deg,nodes in G.sorting.items():
        if deg==0:
            pass
        else:
            L=len(nodes)
            temp=[]
            temp+=[(node_index,node_index+L)]
            temp+=[np.array([list(G.predecessors(n)) for n in nodes])]
            temp+=[np.array([G.edges[e][delay_key] \
                for e in G.in_edges(nodes,keys=True)]).reshape((len(nodes),deg))]
            res+=[temp]
            node_index+=L
    return res

# Cell
def dde_iter(G : Network,
             delay_key : str = 'delay') -> List[List[Union[tuple,np.ndarray,np.ndarray]]]:
    '''
    Construct a list of iterables used in the calculation
    of a delay-differential-equation (dde) for a network `G`.
    Returns a list-of-lists containing  [(node_start,node_stop),
    adjacency matrix, delay matrix] for each in-degree group.
    '''
    node_bounds=[]
    adj_matrices=[]
    delay_matrices=[]
    node_index=0
    for deg,nodes in G.sorting.items():
        if deg==0:
            pass
        else:
            L=len(nodes)
            node_bounds+=[(node_index,node_index+L)]
            adj_matrices+=[np.array([list(G.predecessors(n)) for n in nodes])]
            delay_matrices+=[np.array([G.edges[e][delay_key] \
                for e in G.in_edges(nodes,keys=True)]).reshape((len(nodes),deg))]
            node_index+=L
    return node_bounds,adj_matrices,delay_matrices