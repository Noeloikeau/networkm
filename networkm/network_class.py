# AUTOGENERATED! DO NOT EDIT! File to edit: 02_network_class.ipynb (unless otherwise specified).

__all__ = ['Network']

# Cell
import warnings
with warnings.catch_warnings(): #ignore warnings
    warnings.simplefilter("ignore")
    import networkx as nx
    import numpy as np
    import sidis
    rng=sidis.RNG(0)
    import matplotlib.pyplot as plt
    import typing
    from typing import Optional, Tuple, Dict, Callable, Union, Mapping, Sequence, Iterable, Hashable, List, Any
    from collections import namedtuple

    from .graph_functions import *
    from .model_functions import *

# Cell
class Network(nx.MultiDiGraph):
    '''
    Generic network model class. Has base functionality for incorporating
    a network and simulating its dynamics, as well as executing arbitrary
    routines. Can pass a network `g`, `node_data`, `edge_data`, and `kwargs`
    which get placed as attributes. `routines` is a list of functions,
    args, kwargs, and optional string attributes, which specify a list
    of functions to execute over the args and kwargs, and whether to set
    the result as an attribute of the model. This allows for arbitrary
    executions of routines. Finally, `derivative`, `integrator`, and
    `visualizer` specify the state-change and plotting functions.

    Parameters:
        g : incoming graph data
        node_data : dict containing
            a : node sigmoid parameter, use np.inf for rounding
            tau : node time constant, use scalar for single time constant,
                or tuple (rise,fall) for rise and fall behavior
            f : node boolean function
        edge_data : dict containing
            delay : time-delay along the given edge
            replace : None for no edge replacement,
                or a dict containing node attributes of the new
                nodes replacing that edge
        T : integration time
        dt : integration timestep
        epsilon : noise amplitude for positive-definite uniformly random
    '''
    def __init__(self,
                 graph_data = ring(N=16,right=True,left=True,loop=True),
                 node_data = dict(
                     a = (rng.normal,20,0),
                     tau = (rng.normal,0.5,0),
                     f = XOR
                 ),
                 edge_data : dict = dict(
                     delay = (rng.random,0,0),
                 ),
                 convert_edges = dict(
                     lengths = 1,
                     delay = (rng.random,0,0),
                     node_data = dict(
                         a = (rng.normal,20,0),
                         tau = (rng.normal,0.2,0),
                         f = COPY
                     ),
                     label = lambda g,node,iterable : len(g)+iterable
                 ),
                 model_data = dict(
                     T = 15,
                     dt = 0.01,
                     epsilon = 0,
                     initial_conditions = None,
                     hold_times = None
                 ),
                 view='out'
                ):

        #super init
        super().__init__(graph_data)

        self.view(view)

        if model_data:
            self.model(node_data=node_data,
                       edge_data=edge_data,
                       convert_edges=convert_edges,
                       model_data=model_data)
        else:
            if node_data:
                self.give_nodes(data=node_data,**node_data)
            if edge_data:
                self.give_edges(data=edge_data,**edge_data)
            if convert_edges:
                self.convert_edges(edges=convert_edges.get('edges'),
                                   lengths=convert_edges.get('lengths'),
                                   node_data=convert_edges.get('node_data'),
                                   delay=convert_edges.get('delay'))


    def view(self,view='in'):
        '''
        Change default edge view
        '''
        if view=='in':
            self.edge_view=nx.classes.reportviews.InMultiEdgeView

        elif view=='out':
            self.edge_view=nx.classes.reportviews.OutMultiEdgeView


    @nx.MultiDiGraph.edges.getter
    def edges(self):
        return self.edge_view(self)


    def sort(self,**kwargs):
        sort_graph(self,**kwargs)


    def relabel(self,mapping=None):
        relabel_graph(self,mapping)


    def node_attrs(self):
        return node_attrs(self)


    def edge_attrs(self):
        return edge_attrs(self)


    def attrs(self):
        return self.node_attrs()+self.edge_attrs()


    def give_nodes(self,data=None,nodes=None,**kwargs):
        give_nodes(self,data=data,nodes=nodes,**kwargs)


    def give_edges(self,data=None,edges=None,**kwargs):
        give_edges(self,data=data,edges=edges,**kwargs)


    def give_self(self,data=None,**kwargs):
        '''
        Give any arg dict and kwargs to self as attrs
        '''
        try:
            sidis.give(self,**parse_kwargs(**kwargs))
        except:
            pass

        if data:
            for k,v in data.items():
                try:
                    self.__dict__.update(parse_kwargs(**v))
                except KeyError:
                    pass


    def clear_nodes(self,*args):
        '''
        Remove arg entries from node dict
        '''
        if not args:
            args=self.node_attrs()
        [[sidis.give(self.node[n],arg,None) for n in self.nodes] for arg in args]


    def clear_edges(self,*args):
        '''
        Remove arg entries from edge dict
        '''
        if not args:
            args=self.edge_attrs()
        [[sidis.give(self.edges[e],arg,None) for e in self.edges] for arg in args]


    def clear_self(self,*args):
        if not args:
            args=list(self.node_attrs())+list(self.edge_attrs())
        [sidis.give(self,arg,None) for arg in args]


    def node_data(self,*args,save=False):
        '''
        Set node attributes as self attribute array.
        '''
        if not save:
            return node_data(self,*args)
        else:
            self.give_self(**node_data(self,*args))


    def edge_data(self,*args,save=False):
        if not save:
            return edge_data(self,*args)
        else:
            self.give_self(**edge_data(self,*args))


    def self_data(self,*args):
        if not args:
            args=self.self_attrs()
        return {k:sidis.get(self,k) for k in args}


    def convert_edges(self,
                      edges : Union[None,tuple,List[tuple]] = None,
                      lengths : Union[str,int,dict] = 1,
                      node_data : dict = {},
                      label : callable = lambda g,node,iterable : len(g)+iterable,
                      **edge_data):

        if label is None:
            label = lambda g,node,iterable : len(g)+iterable
        if lengths is None:
            lengths=1

        self.original_nodes = list(self.nodes)

        convert_edges(self,edges=edges,lengths=lengths,node_data=node_data,label=label,
                      **edge_data)

        self.new_nodes = [n for n in self.nodes if n not in self.original_nodes]


    def where(self,*args,**kwargs):
        return where(self,*args,**kwargs)

    def edgewhere(self,*args):
        return np.array(self.edges)[self.where(*args)]

    def nodewhere(self,*args):
        return np.array(self.nodes)[self.where(*args)]

    def __str__(self):
        return print_graph(self,string=True)

    def __repr__(self):
        s=str(self)
        S=super().__repr__()
        spl=s.split('\n')
        if len(spl)>10:
            spl=spl[:5]+['...']+spl[-5:]
        return S+'\n'+('\n').join(spl)


    def model(self,
              node_data,
              edge_data,
              convert_edges,
              model_data
             ):

        #model attrs
        self.__dict__.update(model_data)
        self.t2i = lambda t: (np.array(t)/self.dt).astype(int)

        #give node/edge attrs
        self.give_nodes(data=node_data,nodes=self.nodes,**node_data)
        self.give_edges(data=edge_data,edges=self.edges,**edge_data)

        #flag for changing challenge behavior
        self.mpx_model = False

        #convert edges to new nodes
        if convert_edges:
            self.convert_edges(edges=convert_edges.get('edges'),
                               lengths=convert_edges.get('lengths'),
                               node_data=convert_edges.get('node_data'),
                               delay=convert_edges.get('delay'))

            #if replacing with multiplexers
            if convert_edges['lengths']==1:
                self.mpx_model = True

        #transform delays to int
        for e in self.edges:
            self.edges[e]['delay']=self.t2i(self.edges[e]['delay'])

        #save new data
        self.node_data(save=True)
        self.edge_data(save=True)

        #sort graph
        self.sort(relabel=True)

        #get iterable
        self.graph_iter = graph_iter(self,
                                     graph_keys='predecessors',
                                     edge_keys='delay',
                                     node_keys='a')

        #integrate
        self.integrate(initial_conditions=self.initial_conditions,
                       hold_times=self.hold_times)

        self.plot()


    def parse_initial_conditions(self,
                                 initial_conditions=None,
                                 hold_times=None
                                ):

        if self.mpx_model:
            if initial_conditions is None: #default to 1 logic high node
                initial_conditions = [1]+[0 for i in self.new_nodes[1:]]

            #set original nodes to 0
            initial_conditions = np.array([0 for i in self.original_nodes]+initial_conditions)

            if hold_times is None: #default to hold time of 1 for mpxs
                hold_times = [1 for i in self.new_nodes]

            #don't hold non-mpxs
            hold_times = np.array([0 for i in self.original_nodes]+hold_times)

        else: #not mpx model; need to transform challenge
            if initial_conditions is None: #default to 1 node logic high
                initial_conditions = [1]+[0 for i in range(len(self)-1)]

            #transform challenge by evaluating boolean func
            initial_conditions=np.array([self.f[n](*[initial_conditions[j] \
                  for j in list(self.predecessors(n))]) for n in self.nodes])

            #default to hold time of 1
            if hold_times is None:
                hold_times = np.array([1 for i in self.nodes])

        #change to index
        #hold_times = self.t2i(hold_times)

        return initial_conditions,hold_times


    def integrate(self,
                  initial_conditions = None,
                  hold_times = None
                 ):

        self.initial_conditions,self.hold_times=self.parse_initial_conditions(initial_conditions,
                                                                              hold_times)
        self.x=dde_integrator(dt=self.dt,
                         T=self.T,
                         initial_conditions = self.initial_conditions,
                         hold_times = self.hold_times,
                         f = self.f,
                         tau = self.tau,
                         epsilon = self.epsilon,
                         iterator = self.graph_iter)

    def plot(self,reset : bool = False,
              X : float = 5,
              Y : float = 3.5,
              hspace : float = 0,
              offset : float = 1,
              font : str = 'sans-serif',
              fontsize : int = 12,
              ticksize : int = 6,
              tickwidth : int = 2,
              linewidth : int = 2):
        sidis.figParams(reset,X,Y,hspace,offset,font,fontsize,ticksize,tickwidth,linewidth)
        for group in self.graph_iter:
            nodes=group.slice
            for i in range(*nodes):
                plt.plot(np.arange(int(self.T/self.dt))*self.dt,self.x[:,i])
                title=f'In-Degree {self.in_degree(nodes[0])}: Nodes {nodes[0]} to {nodes[1]-1}'
                plt.title(title)
                plt.xlabel('Time (ns)')
                plt.ylabel('Amplitude')
            plt.show()